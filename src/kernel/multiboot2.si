MultiBoot2 := module {
    [[ extern ]] multiboot_magic:      u32;
    [[ extern ]] multiboot_info_addr: *u8;

    TAG_ALIGN:                 u32 = ~~8;
    TAG_TYPE_END:              u32 = ~~0;
    TAG_TYPE_CMDLINE:          u32 = ~~1;
    TAG_TYPE_BOOT_LOADER_NAME: u32 = ~~2;
    TAG_TYPE_MODULE:           u32 = ~~3;
    TAG_TYPE_BASIC_MEMINFO:    u32 = ~~4;
    TAG_TYPE_BOOTDEV:          u32 = ~~5;
    TAG_TYPE_MMAP:             u32 = ~~6;
    TAG_TYPE_VBE:              u32 = ~~7;
    TAG_TYPE_FRAMEBUFFER:      u32 = ~~8;
    TAG_TYPE_ELF_SECTIONS:     u32 = ~~9;
    TAG_TYPE_APM:              u32 = ~~10;
    TAG_TYPE_EFI32:            u32 = ~~11;
    TAG_TYPE_EFI64:            u32 = ~~12;
    TAG_TYPE_SMBIOS:           u32 = ~~13;
    TAG_TYPE_ACPI_OLD:         u32 = ~~14;
    TAG_TYPE_ACPI_NEW:         u32 = ~~15;
    TAG_TYPE_NETWORK:          u32 = ~~16;
    TAG_TYPE_EFI_MMAP:         u32 = ~~17;
    TAG_TYPE_EFI_BS:           u32 = ~~18;
    TAG_TYPE_EFI32_IH:         u32 = ~~19;
    TAG_TYPE_EFI64_IH:         u32 = ~~20;
    TAG_TYPE_LOAD_BASE_ADDR:   u32 = ~~21;

    Info := struct {
        size:      u32,
        _reserved: u32,
    }

    Tag := struct {
        ty:   u32,
        size: u32,
    }

    enumerate_tags := proc() {
        info: *Info = ~~multiboot_info_addr;

        kprint("======== MultiBoot2 ========\n");
        kprint("magic:   {X}\n", multiboot_magic);
        kprint("address: {}\n", multiboot_info_addr);
        kprint("  size:  {}\n", info.size);

        ptr := multiboot_info_addr + 8;

        tag: *Tag = ~~ptr;
        loop ; tag.ty != TAG_TYPE_END;  {
            kprint("    TAG @ {}: {}, size {}\n", cast(*u8, tag), tag.ty, tag.size);
            ptr += tag.size;
            loop ; cast(u64, ptr) & 0x7; { ptr += 4; }
            tag = ~~ptr;
        }
        kprint("    TAG @ {}: {}, size {}\n", cast(*u8, tag), tag.ty, tag.size);
        kprint("Done.\n");
    }
}
